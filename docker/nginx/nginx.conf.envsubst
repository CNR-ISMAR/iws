# NOTE : $VARIABLES are env variables replaced by entrypoint.sh using envsubst
# not to be mistaken for nginx variables (also starting with $, but usually lowercase)

worker_processes auto;

events {

}

http {
    server_names_hash_bucket_size  64;

    # Allow Nginx to resolve Docker host names (see https://sandro-keil.de/blog/2017/07/24/let-nginx-start-if-upstream-host-is-unavailable-or-down/)
    resolver $RESOLVER; # it seems rancher uses 169.254.169.250 instead of 127.0.0.11 which works well in docker-compose (see /etc/resolv.conf)

    # https - listens on specific name - this uses letsencrypt cert
    # this includes a symlink that links either to nginx.https.available.conf if https in enabled
    # or to an empty file if https is disabled.
    include nginx.https.enabled.conf;

    # http - listens to specific HTTP_HOST only - this is not encrypted (not ideal but admissible on LAN for instance)
    # even if not used (HTTP_HOST empty), we must keep it as it's used for internal API calls between django and geoserver
    # TODO : do not use unencrypted connection even on LAN, but is it possible to have browser not complaining about unknown authority ?
    server {
        listen              $HTTP_PORT;
        server_name         $HTTP_HOST 127.0.0.1 geonode localhost;

        include sites-enabled/*.conf;
    }
    # server directive for open I-storms
    server{
      listen 80;
      listen 443 ssl;
      ssl_certificate /etc/ssl/certs/seastorms.eu/seastorms.eu.crt;
      ssl_certificate_key /etc/ssl/private/seastorms.eu.key;
      ssl_protocols       TLSv1 TLSv1.1 TLSv1.2;
      ssl_ciphers         HIGH:!aNULL:!MD5;
      server_name www.seastorms.eu;
      location / {
        etag off;
        expires 0;
        proxy_pass http://istorm:3000;
        proxy_redirect     off;
        proxy_set_header   Host $host;
        proxy_set_header   X-Real-IP $remote_addr;
     }
  }




    # Default server closes the connection (we can connect only using HTTP_HOST and HTTPS_HOST)
    server {
        listen          $HTTP_PORT default_server;
        listen          $HTTPS_PORT;
        server_name     _;
        return          444;
    }

}
